{% extends "base.html" %}
{% block content %}
<div class="container" style="max-width: 860px;">
    <h1>Pattern Generator</h1>
    <p style="margin: 0 0 12px; opacity: 0.85;">Connector-aware KMS controls. Use <strong>Reload Outputs</strong> to confirm what the backend discovers.</p>
    <div id="capability_notice" style="margin:0 0 12px; padding:10px; border-radius:6px; background:#3b1f1f; color:#ffd6d6; display:none;"></div>

    <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:12px; align-items:center;">
        <button onclick="loadOutputs()">Reload Outputs</button>
        <span id="active_connector_badge" style="padding:4px 10px; border-radius:999px; background:#1f2937; color:#f3f4f6; font-size:13px;">Active connector: 33</span>
    </div>

    <label for="screen_select">Screen</label>
    <select id="screen_select" style="display:block; margin: 8px 0 8px; padding: 8px; width: 360px;">
        <option value="33" selected>Fallback connector (33)</option>
        <option value="custom">Custom connector id…</option>
    </select>

    <label for="custom_connector_id">Custom connector id</label>
    <input id="custom_connector_id" type="number" min="0" value="33" style="display:block; margin: 8px 0 16px; padding: 8px; width: 220px;" />

    <div style="display:flex; gap:8px; flex-wrap: wrap; margin-bottom: 16px;">
        <button onclick="takeControl()">Take Display Control (Global)</button>
        <button onclick="releaseControl()">Release Display Control (Global)</button>
        <button onclick="startPattern()">Start</button>
        <button onclick="stopPattern()">Stop</button>
    </div>

    <label for="color_picker">Colour</label>
    <input id="color_picker" type="color" value="#ffffff" style="display:block; width:120px; height:48px; border:none; padding:0; background:none; margin:8px 0;" />
    <button onclick="showColor()">Display Full Screen Colour (KMS)</button>

    <pre id="status" style="margin-top: 16px; background:#111; color:#eee; padding: 12px; border-radius: 6px; min-height: 52px;">Loading outputs…</pre>

    <h3 style="margin:16px 0 8px;">Discovered Outputs (debug)</h3>
    <pre id="outputs_debug" style="margin-top: 0; background:#0b1220; color:#d1d5db; padding: 12px; border-radius: 6px; min-height: 80px;">(not loaded)</pre>
</div>

<script>
const screenSelect = document.getElementById('screen_select');
const customConnectorInput = document.getElementById('custom_connector_id');
const activeConnectorBadge = document.getElementById('active_connector_badge');
const outputsDebug = document.getElementById('outputs_debug');
const capabilityNotice = document.getElementById('capability_notice');
let connectorSelectionSupported = true;

function setStatus(message) {
    document.getElementById('status').textContent = message;
}

function selectedConnectorId() {
    if (screenSelect.value === 'custom') {
        return Number(customConnectorInput.value || 33);
    }

    return Number(screenSelect.value);
}

function refreshActiveConnectorBadge() {
    activeConnectorBadge.textContent = `Active connector: ${selectedConnectorId()}`;
}

async function postJson(url, payload = {}) {
    const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });

    const body = await response.json().catch(() => ({}));
    if (!response.ok) {
        throw new Error(body.error || `Request failed (${response.status})`);
    }
    return body;
}

async function loadCapabilities() {
    try {
        const response = await fetch('/pattern/capabilities');
        const data = await response.json();
        connectorSelectionSupported = Boolean(data.connector_selection_supported);

        if (!connectorSelectionSupported) {
            capabilityNotice.style.display = 'block';
            capabilityNotice.textContent = 'This kmscube build cannot target specific connectors. Screen select is disabled and output may appear on the default screen.';
            screenSelect.disabled = true;
            customConnectorInput.disabled = true;
        } else {
            capabilityNotice.style.display = 'none';
            capabilityNotice.textContent = '';
            screenSelect.disabled = false;
            customConnectorInput.disabled = false;
        }
    } catch (err) {
        capabilityNotice.style.display = 'block';
        capabilityNotice.textContent = `Could not read capabilities: ${err.message}`;
    }
}

async function loadOutputs() {
    try {
        const response = await fetch('/pattern/outputs');
        const outputs = await response.json();
        const list = Array.isArray(outputs) ? outputs : [];

        outputsDebug.textContent = JSON.stringify(list, null, 2);
        screenSelect.innerHTML = '';

        const connected = list.filter(o => o.connected);
        const withIds = connected.filter(o => o.connector_id !== null);

        withIds.forEach((output, index) => {
            const option = document.createElement('option');
            option.value = String(output.connector_id);
            option.textContent = `${output.name} (id ${output.connector_id})`;
            if (index === 0) {
                option.selected = true;
                customConnectorInput.value = String(output.connector_id);
            }
            screenSelect.appendChild(option);
        });

        if (withIds.length === 0) {
            const fallbackOption = document.createElement('option');
            fallbackOption.value = '33';
            fallbackOption.textContent = connected.length > 0
                ? 'Connected outputs found but no connector_id (fallback 33)'
                : 'No connected outputs found (fallback connector 33)';
            fallbackOption.selected = true;
            screenSelect.appendChild(fallbackOption);
        }

        const customOption = document.createElement('option');
        customOption.value = 'custom';
        customOption.textContent = 'Custom connector id…';
        screenSelect.appendChild(customOption);

        refreshActiveConnectorBadge();
        setStatus(`Outputs loaded: ${list.length} total, ${connected.length} connected, ${withIds.length} with connector IDs.${connectorSelectionSupported ? "" : " Connector-specific targeting not supported on this kmscube build."}`);
    } catch (err) {
        outputsDebug.textContent = `(failed to load outputs) ${err.message}`;
        setStatus(`Error loading outputs: ${err.message}. Using fallback connector options.`);
        refreshActiveConnectorBadge();
    }
}

screenSelect.addEventListener('change', () => {
    if (screenSelect.value !== 'custom') {
        customConnectorInput.value = screenSelect.value;
    }
    refreshActiveConnectorBadge();
});

customConnectorInput.addEventListener('input', refreshActiveConnectorBadge);

async function takeControl() {
    const connector_id = selectedConnectorId();
    try {
        const result = await postJson('/pattern/control', { action: 'take' });
        setStatus(result.message || 'Display control taken.');
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

async function releaseControl() {
    const connector_id = selectedConnectorId();
    try {
        const result = await postJson('/pattern/control', { action: 'release' });
        setStatus(result.message || 'Display control released.');
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

async function startPattern() {
    const connector_id = selectedConnectorId();
    try {
        const result = await postJson('/pattern/start', { connector_id });
        const warning = result.warning ? ` Warning: ${result.warning}` : '';
        setStatus(`Pattern started on connector ${connector_id}.${warning}`);
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

async function stopPattern() {
    const connector_id = selectedConnectorId();
    try {
        await postJson('/pattern/stop', { connector_id });
        setStatus(`Pattern stopped on connector ${connector_id}.`);
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

async function showColor() {
    const connector_id = selectedConnectorId();
    const color = document.getElementById('color_picker').value;

    try {
        const result = await postJson('/pattern/start', { connector_id, color, mode: 'solid' });
        const warning = result.warning ? ` Warning: ${result.warning}` : '';
        setStatus(`Requested colour ${color} on connector ${connector_id} via KMS process.${warning}`);
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

refreshActiveConnectorBadge();
loadCapabilities().then(loadOutputs);
</script>
{% endblock %}
