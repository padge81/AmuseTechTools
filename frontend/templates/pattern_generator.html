{% extends "base.html" %}
{% block content %}
<div class="container" style="max-width: 900px;">
    <h1>Pattern Generator</h1>
    <p style="opacity:0.85;">A) Select display. B) Take/Release selected display. C) Full-screen solid colour. D) Colour bars.</p>

    <label for="screen_select">Available Displays</label>
    <select id="screen_select" style="display:block; margin:8px 0 16px; padding:8px; width:420px;"></select>

    <div style="display:flex; gap:8px; flex-wrap: wrap; margin-bottom:16px;">
        <button onclick="takeControl()">Take Selected Display</button>
        <button onclick="releaseControl()">Release Selected Display</button>
        <button onclick="reloadOutputs()">Reload Displays</button>
    </div>

    <label style="display:block; margin: 0 0 16px;">
        <input id="global_drm_toggle" type="checkbox" disabled />
        Use global DRM control handover (stop display manager) for take/release
    </label>
    <p style="margin-top:-10px; margin-bottom:16px; opacity:0.85; color:#fbbf24;">
        Note: global DRM handover is system-wide and can affect all displays.
    </p>

    <label for="color_picker">Solid Colour</label>
    <input id="color_picker" type="color" value="#ffffff" style="display:block; width:120px; height:48px; border:none; padding:0; background:none; margin:8px 0;" />

    <div style="display:flex; gap:8px; flex-wrap: wrap; margin-bottom:16px;">
        <button onclick="startSolidColor()">Start Full Screen Colour</button>
        <button onclick="startColorBars()">Start Colour Bars</button>
        <button onclick="stopPattern()">Stop Pattern On Selected Display</button>
    </div>

    <pre id="status" style="margin-top: 8px; background:#111; color:#eee; padding: 12px; border-radius: 6px; min-height: 52px;">Loading capabilities and displays...</pre>
    <pre id="outputs_debug" style="margin-top: 8px; background:#0b1220; color:#d1d5db; padding: 12px; border-radius: 6px; min-height: 80px;">(outputs)</pre>
</div>

<script>
const screenSelect = document.getElementById('screen_select');

function setStatus(message) {
    document.getElementById('status').textContent = message;
}

function selectedConnectorId() {
    return Number(screenSelect.value);
}

async function postJson(url, payload = {}) {
    const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    });

    const body = await response.json().catch(() => ({}));
    if (!response.ok) {
        throw new Error(body.error || `Request failed (${response.status})`);
    }
    return body;
}

async function loadCapabilities() {
    try {
        const response = await fetch('/pattern/capabilities');
        const caps = await response.json();
        const scope = caps.display_control_scope || 'unknown';
        const handoverScope = caps.global_drm_handover_scope || 'unknown';
        const globalMode = caps.force_global_drm_control ? 'FORCED' : (caps.allow_global_drm_control ? 'AVAILABLE' : 'DISABLED');
        const protectedConnectors = Array.isArray(caps.protected_connectors) ? caps.protected_connectors.join(', ') : '(none)';
        const toggle = document.getElementById('global_drm_toggle');
        toggle.checked = !!caps.force_global_drm_control;
        toggle.disabled = !!caps.force_global_drm_control || !caps.allow_global_drm_control;
        setStatus(`Capabilities: scope=${scope}, global_handover_scope=${handoverScope}, global_mode=${globalMode}, protected_connectors=${protectedConnectors}.`);
    } catch (err) {
        setStatus(`Could not load capabilities: ${err.message}`);
    }
}

function useGlobalDrmControl() {
    const toggle = document.getElementById('global_drm_toggle');
    return !!(toggle && toggle.checked);
}

async function reloadOutputs() {
    try {
        const response = await fetch('/pattern/outputs');
        const outputs = await response.json();
        const list = Array.isArray(outputs) ? outputs : [];

        document.getElementById('outputs_debug').textContent = JSON.stringify(list, null, 2);
        screenSelect.innerHTML = '';

        const connected = list.filter(o => o.connected && o.connector_id !== null);
        connected.forEach((output, index) => {
            const option = document.createElement('option');
            option.value = output.connector_id;
            option.textContent = `${output.name} (connector ${output.connector_id})`;
            if (index === 0) option.selected = true;
            screenSelect.appendChild(option);
        });

        if (connected.length === 0) {
            const option = document.createElement('option');
            option.value = '33';
            option.textContent = 'No connected display with connector id found (fallback 33)';
            option.selected = true;
            screenSelect.appendChild(option);
        }

        setStatus(`Displays loaded. Connected selectable displays: ${connected.length}.`);
    } catch (err) {
        setStatus(`Error loading displays: ${err.message}`);
    }
}

async function takeControl() {
    const connector_id = selectedConnectorId();
    try {
        const result = await postJson('/pattern/control', {
            action: 'take',
            connector_id,
            global_drm_control: useGlobalDrmControl(),
        });
        const warning = result.warning ? ` Warning: ${result.warning}` : '';
        setStatus(`${result.message}${warning} Owned connectors: ${result.owned_connectors.join(', ') || '(none)'}`);
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

async function releaseControl() {
    const connector_id = selectedConnectorId();
    try {
        const result = await postJson('/pattern/control', {
            action: 'release',
            connector_id,
            global_drm_control: useGlobalDrmControl(),
        });
        setStatus(`${result.message} Owned connectors: ${result.owned_connectors.join(', ') || '(none)'}`);
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

async function startSolidColor() {
    const connector_id = selectedConnectorId();
    const color = document.getElementById('color_picker').value;

    try {
        await postJson('/pattern/start', { connector_id, mode: 'solid', color });
        setStatus(`Started full-screen colour ${color} on connector ${connector_id}.`);
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

async function startColorBars() {
    const connector_id = selectedConnectorId();

    try {
        await postJson('/pattern/start', { connector_id, mode: 'colorbars' });
        setStatus(`Started colour bars on connector ${connector_id}.`);
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

async function stopPattern() {
    const connector_id = selectedConnectorId();

    try {
        await postJson('/pattern/stop', { connector_id });
        setStatus(`Stopped pattern on connector ${connector_id}.`);
    } catch (err) {
        setStatus(`Error: ${err.message}`);
    }
}

loadCapabilities().then(reloadOutputs);
</script>
{% endblock %}
